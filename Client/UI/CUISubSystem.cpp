/* 
 * File:   CUISubSystem.cpp
 * Author: karsten
 * 
 * Created on 3. august 2011, 16:33
 */

#include "CUIMainFrame.h"


#include "CUISubSystem.h"
#include "Buttons/CUIButtonItem.h"

#include "Buttons/CUIButtonChangeTG.h"

#include "CUIComboBox.h"

CUISubSystem::CUISubSystem(CUIBaseFrame* parrent , CSlotNode& slotNode):
CUIButton(parrent)
{
	this->_slot = &slotNode;
	slotNode.getST();
	_x = slotNode.getST()->uiX();
	_y = slotNode.getST()->uiY();
	_wight = 45;
	_hight = 36;
}

void CUISubSystem::Draw(){
	//begin hpstatus

		
	for (list<CUIBaseFrame*>::iterator it = _frames.begin(); it != _frames.end(); it++){
		(*it)->Draw();
	}

	this->DrawBack();
	this->DrawCDs();

}
string CUISubSystem::getHoverMsg(){

	if(_slot){
		if(_slot->getSS()){
			if(_slot->getSS()->getItemType()){
				return _slot->getSS()->getItemType()->getName();
			}
		}
	}
	return "";
}

void CUISubSystem::Click(SDL_Event event, int32_t x, int32_t y){
	cerr<<"click subsystem"<<endl;
	if(event.button.button == SDL_BUTTON_LEFT){
		if (mainFrame->shipDetail()){
			if (mainFrame->shipDetail()->getChangeSubTargetGroup()){
				cerr<<"remove getchange"<<endl;
				mainFrame->shipDetail()->remove(*mainFrame->shipDetail()->getChangeSubTargetGroup());
				delete mainFrame->shipDetail()->getChangeSubTargetGroup();
			}
			mainFrame->shipDetail()->setChangeSubTargetGroup(new CUIComboTgChange(mainFrame->shipDetail(),100,500,80,14*6)) ;

			CUIComboTgChange* temp = mainFrame->shipDetail()->getChangeSubTargetGroup();
			mainFrame->shipDetail()->add(*temp);
			temp->AddButton(*(new CUIButtonChangeTG(temp,TargetGroup::Primary)));
			temp->AddButton(*(new CUIButtonChangeTG(temp,TargetGroup::Light)));
			temp->AddButton(*(new CUIButtonChangeTG(temp,TargetGroup::Medium)));
			temp->AddButton(*(new CUIButtonChangeTG(temp,TargetGroup::Heavy)));
			temp->AddButton(*(new CUIButtonChangeTG(temp,TargetGroup::Special)));
		}
		if(SDL_GetModState() & KMOD_SHIFT)
			mainFrame->SetSelSlot(this->_slot,true);
		else
			mainFrame->SetSelSlot(this->_slot,false);


		//DRAG
		if(_slot && SDL_GetModState() & KMOD_SHIFT){
			if(_slot->getSS()){
				CUIButtonItem* temp = new CUIButtonItem(this, 0,0,40,40, this->_slot,_slot->getSS()->Xitem());
				selectedFrame = temp;
				temp->drag();
				temp->SetX(event.button.x-30);
				temp->SetY(event.button.y-30);
				temp->setDrawFront(true);

				this->add(*temp);
				//END DRAG
			}
		}
		
	}else if (event.button.button == SDL_BUTTON_RIGHT){
		if( x < 20)
			playerObj->ServerRequestChangeSubStatus(this->_slot,!this->_slot->getSS()->online(), this->_slot->getSS()->recharge()); //TODO implement recharge and keycombos
		if(x > 20)
			playerObj->ServerRequestChangeSubStatus(this->_slot,this->_slot->getSS()->online(), !this->_slot->getSS()->recharge()); //TODO implement recharge and keycombos
	}
}

void CUISubSystem::OnDrop(CUIButtonItem* frame){
	cerr<<"droping here subsystem"<<endl;
	if(!frame->getSlot())
		playerObj->ServerRequsetFit(this->_slot,frame->getCargoBay(),frame->getItem(),frame->getQuan());
}

void CUISubSystem::Move(SDL_Event event,int32_t x, int32_t y){
	hoverFrame = this;
}

void CUISubSystem::DrawCDs(){
	if(this->_slot->getSS()){

		for(list<CSlotNode*>::iterator it = mainFrame->GetSelSlotList().begin(); it != mainFrame->GetSelSlotList().end();it++){
			if(*it == _slot){
				Drawbox(_x,_y-2,45,2,1,1,1,0.9f);
				break;
			}
		}

		for(uint16_t i = 0; i< this->_slot->getSS()->Xitem();i++){

			if (this->_slot->getSS()->maxcooldown(i)){
				double x2 = (this->_slot->getSS()->cooldown(i)*41)/this->_slot->getSS()->maxcooldown(i);

				Drawbox(_x,_y+(i*9),x2,9,1,1,1,0.9f);

			}
			if(this->_slot->getSS()->getMaxAmo()){
				uint32_t beg = (36*(double)this->_slot->getSS()->getAmo()/this->_slot->getSS()->getMaxAmo());
				Drawbox(_x+41,_y,4,36,0,1,0,1);
				Drawbox(_x+41,_y,4,(double)36-beg,1,0,0,1);
			}

			//draw status icon
			if (this->_slot->getSS()->online())
				Drawbox(_x,_y+(i*9),4,4,0,0,1,1);
			else
				Drawbox(_x,_y+(i*9),4,4,1,1,0,1);

			if (this->_slot->getSS()->recharge())
				Drawbox(_x+2,_y+(i*9),2,4,0.5,0.5,0.5,1);
			
			if(this->_slot->getSS()->isLocking(i)){
				uint32_t c = (this->_slot->getSS()->getGraficCounter()% 450)/20;
				
				Drawbox(_x+c ,_y+(i*9),2,9,1,0,0,0.5);
				Drawbox(_x+2+c,_y+(i*9),2,9,1,0,0,0.8);
				Drawbox(_x+40-c,_y+(i*9),2,9,1,0,0,0.8);
				Drawbox(_x+42-c,_y+(i*9),2,9,1,0,0,0.5);
			}
		}

	}
}

void CUISubSystem::DrawBack(){
	int32_t uvx1;
	int32_t uvy1;
	uint32_t sheetsize;
	if (this->_slot->getSS()){
		sheetsize = 1024;
		switch (this->_slot->getSS()->getItemType()->getPicID()){

		//*****************************************
		//file generated by python spritesheet
		#include "../Textures/Items/subcords.txt"

		//**************************************************
			default:{
			glBindTexture( GL_TEXTURE_2D, textures[Textures::SubItemSheet]);

			uvx1 = 0;
			uvy1 = 0;
			cerr<<"Warning subitemsheed tex"<<endl;
			break;
			}
		}
	}else{
		sheetsize = 256;
		switch (this->_slot->getST()->slotType()){

		//*****************************************
		//file generated by python spritesheet
		#include "../Textures/SlotPic/cords.txt"

		//**************************************************
			default:{
			glBindTexture( GL_TEXTURE_2D, textures[Textures::SlotSheet]);

			uvx1 = 0;
			uvy1 = 0;
			cerr<<"Warning slotsheet tex"<<endl;
			break;
			}
		}
	}
	
	glLoadIdentity();
	glTranslated((GLfloat)(_x),(GLfloat)(_y),0);

	glBegin( GL_QUADS );
	//Bottom-left vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1), (((double)1)/sheetsize)*(uvy1) );
	glVertex3f(0, 0, 0.0f);

	//Bottom-right vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1+_wight), (((double)1)/sheetsize)*(uvy1) );
	glVertex3f(_wight, 0, 0.f);

	//Top-right vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1+_wight), (((double)1)/sheetsize)*(uvy1+_hight) );
	glVertex3f(_wight, _hight, 0.f);

	//Top-left vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1), (((double)1)/sheetsize)*(uvy1+_hight) );
	glVertex3f(0, _hight, 0.f);
	glEnd();


}


CUISubSystem::~CUISubSystem() {

	for (list<CUIBaseFrame*>::iterator it = _frames.begin(); it != _frames.end(); it++){
		if (selectedFrame == (*it)){
			selectedFrame = NULL;
		}
		delete (*it);
	}
}

