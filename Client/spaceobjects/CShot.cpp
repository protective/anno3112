/* 
 * File:   CShot.cpp
 * Author: karsten
 * 
 * Created on 2. juli 2011, 14:37
 */

#include "CShot.h"

CShot::CShot(uint32_t id, uint32_t playerId, CPos& pos, CPos& target, uint32_t texId, uint32_t speed) :
CObj(id,playerId,pos) , CMovable(this,0,0), CUIBaseFrame((CUIBaseFrame*)mainFrame)
{
	this->_targetPos.x = target.x;
	this->_targetPos.y = target.y;
	this->_targetPos.d = target.d;
	this->_texId = texId;
	this->_speed = speed;
	this->_pos.d = (100 * Deg(this->_targetPos.x-this->_pos.x,this->_targetPos.y-this->_pos.y));
	_UIlevel = 1;
	_flightTime = 0;
	_maxFlightTime = 0;
	_movedis = 0;
	_length = 0;
	_ending = false;
}

void CShot::Draw(){
	//cerr<<"ShotDraw"<<endl;

	uint32_t uvx1 = 0;
	uint32_t wight = 128;
	uint32_t uvy1 = 0;
	uint32_t hight = 5;
	uint32_t front = 0;

	uint32_t sheetsize;
	sheetsize = 128;

	switch (this->_texId){

	//*****************************************
	//file generated by python spritesheet
	#include "../Textures/shots/cords.txt"

	//**************************************************
		default:{

		uvx1 = 0;
		uvy1 = 0;
		cerr<<"Warning objsheed tex"<<endl;
		break;
		}
	}
	_length = wight;
	if (wight > _movedis/100)
		wight = _movedis/100;
	
	if(_ending)
		front = min(wight, (uint32_t)((_movedis - _finalmovedis)/100));
	
	double a = 1;
	if (_flightTime > _maxFlightTime){
		a = 1-((double)(_flightTime-_maxFlightTime)/500);
	}
	glColor4f(1, 1, 1, a);
	glBindTexture( GL_TEXTURE_2D, textures[Textures::ShotSheet] );
	glLoadIdentity();
	glTranslated((GLfloat)(((this->_pos.x-viewPos->x)*viewZoom)/100),(GLfloat)(((this->_pos.y-viewPos->y)*viewZoom)/100),0);
	glRotatef((GLfloat)(180-(this->_pos.d/100)),0,0,0.1);
	glBegin( GL_QUADS );


	//Bottom-left vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1), (((double)1)/sheetsize)*(uvy1) );
	glVertex3f(front, 0, 0.0f);

	//Bottom-right vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1+wight), (((double)1)/sheetsize)*(uvy1) );
	glVertex3f(wight*viewZoom, 0, 0.f);

	//Top-right vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1+wight), (((double)1)/sheetsize)*(uvy1+hight) );
	glVertex3f(wight*viewZoom, hight*viewZoom, 0.f);

	//Top-left vertex (corner)
	glTexCoord2f((((double)1)/sheetsize)*(uvx1), (((double)1)/sheetsize)*(uvy1+hight) );
	glVertex3f(front, hight*viewZoom, 0.f);

	glColor4f(1, 1, 1, 1);
	glEnd();
}


void CShot::Proces(uint32_t DTime){

	while(this->_procedTime<= getTime()){
		this->_procedTime += 1000/25;

		if(_trackingTime && _target){
			int32_t targetDir = 0;
			int32_t b;
			targetDir = (100 * Deg(_target->obj()->getPos().x -this->_pos.x,_target->obj()->getPos().y -this->_pos.y));
			if (targetDir >= this->_pos.d)
				b = targetDir - this->_pos.d;
			else
				b = targetDir + 36000 - this->_pos.d;
			if (b > 18000)
				this->_pos.turn((int32_t)-this->_tracking);
			else
				this->_pos.turn((int32_t)this->_tracking);
		}

		
	}
	_flightTime +=DTime;
	this->Move(getTime() - this->_lastUpdate);
	switch (this->_texId){
		case 7:{//missile
			particals.push_back(new CPartical(ParticalTex::MissileTail1, _pos));
			break;
		}
		case 8:{//plasma
			particals.push_back(new CPartical(ParticalTex::plasma1, _pos));
			break;
		}
		default:{
			break;
		}
	}
	this->_lastUpdate = getTime();
}

bool CShot::canBeRemoved(){
	if(_flightTime >= _maxFlightTime+500){
		return true;
	}else
		return false;
}

void CShot::finishMe(){
	cerr<<"finishMe"<<endl;
	this->_flightTime = _maxFlightTime+500 - ((double)_length*100/_speed);
	_finalmovedis = this->_movedis;
	this->_ending = true;
}

void CShot::Move(uint32_t deltaT){
	uint32_t speed = (_speed * deltaT)/(1000/25);
	_movedis += speed;

	this->MovePos(VektorUnitX(this->_pos.d/100) * speed ,-(VektorUnitY(this->_pos.d/100)* speed ));

}

CShot::~CShot() {

}

